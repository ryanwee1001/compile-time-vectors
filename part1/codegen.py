"""This file generates boilerplate code for summing over a std::vector.

In particular, it generates three files:

1. vec_test_runtime.cpp, which does this computation at runtime
2. vec_test_constexpr.cpp, which does this computation possibly at compile time
3. vec_test_consteval.cpp, which does this computation at compile time

We pre-generate this code, because std::random_device is a runtime random
number generator. To write a constexpr or consteval function, we need to bake
all the elements used to populate the std::vector into the source code itself.
"""


from random import randint
from typing import List


compiletime_contents = """// This file was auto-generated by `codegen.py`.
// Do not modify it manually unless there is good reason to.

#include <chrono>
#include <iostream>
#include <numeric>
#include <vector>

{specifier}long long runTest() {{
    // Populate the std::vector. We can't use a std::random_device to do this,
    // because any memory allocations used for this std::vector must be
    // transient within the runTest() function.
    std::vector<int> v;
{populate_vector}

    // Run the test. Right now, we just do a simple summation.
    long long sum = std::accumulate(v.begin(), v.end(), 0LL);
    return sum;
}}

int main() {{
    // Right now, our timing includes the overhead of a function call, but
    // this is probably necessary since main isn't constexpr or consteval.
    auto start = std::chrono::high_resolution_clock::now();
    long long sum = runTest();
    auto end = std::chrono::high_resolution_clock::now();

    // Print the result so that the compiler doesn't optimize away our code.
    std::cout << "Sum: " << sum << "\\n";

    // Print the amount of time the test took, in nanoseconds.
    std::cout << "Time taken: " << (end - start).count() << " ns\\n";
}}
"""


# The source code when testing at runtime is slightly different, because
# we don't want to include the time taken to populate the vector at runtime.
runtime_contents = """// This file was auto-generated by `codegen.py`.
// Do not modify it manually unless there is good reason to.

#include <chrono>
#include <iostream>
#include <numeric>
#include <vector>

std::vector<int> populateVec() {{
    std::vector<int> v;
{populate_vector}
    return v;
}}

long long runTest(const std::vector<int>& v) {{
    // Run the test. Right now, we just do a simple summation.
    long long sum = std::accumulate(v.begin(), v.end(), 0LL);
    return sum;
}}

int main() {{
    std::vector<int> v = populateVec();
    auto start = std::chrono::high_resolution_clock::now();
    long long sum = runTest(v);
    auto end = std::chrono::high_resolution_clock::now();

    // Print the result so that the compiler doesn't optimize away our code.
    std::cout << "Sum: " << sum << "\\n";

    // Print the amount of time the test took, in nanoseconds.
    std::cout << "Time taken: " << (end - start).count() << " ns\\n";
}}
"""


def generate_filename(test_type: str) -> str:
    return f"vec_test_{test_type}.cpp"


def generate_randomints(size: int) -> List[int]:
    l = []
    for _ in range(size):
        l.append(randint(-1e9, 1e9))
    return l


def generate_populationcode(l: List[int]) -> str:
    s = ""
    for elem in l:
        s += f"    v.push_back({elem});\n"
    return s


def generate_compiletime_code(l: List[int], test_type: str) -> None:
    filename = generate_filename(test_type)
    specifier = test_type + " "
    filecontents = compiletime_contents.format(
        specifier=specifier,
        populate_vector=generate_populationcode(l),
    )
    with open(filename, "w") as f:
        f.write(filecontents)


def generate_runtime_code(l: List[int]) -> None:
    filename = generate_filename("runtime")
    filecontents = runtime_contents.format(
        populate_vector=generate_populationcode(l),
    )
    with open(filename, "w") as f:
        f.write(filecontents)


def main() -> None:
    # By crude binary search, it seems that ~7400 is the maximum number of
    # elements the compiler can handle when doing compile-time computation
    # before it runs out of memory.
    l = generate_randomints(7400)
    generate_runtime_code(l)
    generate_compiletime_code(l, "constexpr")
    generate_compiletime_code(l, "consteval")


if __name__ == '__main__':
    main()
