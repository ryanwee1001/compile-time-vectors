/************************************************************
 * This is a sample file generated by `codegen.py`, where   *
 * the number of elements is 1 and the number of runs is 1. *
 ************************************************************/

// This file was auto-generated by `codegen.py`.
// Do not modify it manually unless there is good reason to.

#include <chrono>
#include <concepts>
#include <iostream>
#include <numeric>
#include <string_view>
#include <type_traits>
#include <vector>

// Checks that some functor Func can be invoked at compile time on a std::vector
// containing elements of type T.
//
// Usage of std::bool_constant was inspired by stackoverflow question 63326542.
template <typename Func, typename T>
concept CompileTimeInvocable = requires (Func f) {
    { std::bool_constant<(Func()(std::vector<T>{}), true)>() };
    { Func()(std::vector<T>{}) } -> std::same_as<T>;
};

// Wrapper around the std::is_arithmetic type trait.
template <typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

// Functor that sums the elements of a vector.
template <Arithmetic T>
struct SimpleSum {
    constexpr T operator()(const std::vector<T>& v) {
        return std::accumulate(v.begin(), v.end(), static_cast<T>(0));
    }
};

// Functor that multiplies the elements of a vector (while taking mod 1e9).
template <Arithmetic T>
struct SimpleProd {
    constexpr T operator()(const std::vector<T>& v) {
        return std::accumulate(v.begin(), v.end(), static_cast<T>(1),
            [](const T& accum, const T& elem) -> T {
                return (accum * elem) % static_cast<T>(1e9);
            }
        );
    }
};

// Populates a std::vector with the same elements used to populate the
// std::vector in the compile-time code.
//
// The repeated statements are ugly, but we do this instead of using a
// std::random_device and a loop so that we can populate the std::vector with
// the same elements used in the compile-time code.
template <typename T>
std::vector<T> populateVec() {
    std::vector<T> v;
    v.emplace_back(-861940221);

    return v;
}

// Performs some computation over the elements of a pre-populated std::vector.
// This function is executed at runtime.
//
// @tparam Func the computation to be executed
// @tparam T the type of elements in the std::vector
template <typename Func, typename T>
requires CompileTimeInvocable<Func, T>
T doComputation(const std::vector<T>& v) {
    return Func()(v);
}

// Wrapper over `doComputation` that:
// (1) executes the test `numRuns` number of times
// (2) times each function call and prints the relevant results
template <typename Func, typename T>
void runTestCase(int numRuns, std::string_view testName) {
    std::vector<T> v = populateVec<T>();
    for (int i = 0; i < numRuns; ++i) {
        auto start = std::chrono::high_resolution_clock::now();
        T res = doComputation<Func, T>(v);
        auto end = std::chrono::high_resolution_clock::now();
        std::cout << testName << " result: " << res << "\n";
        std::cout << testName << " timing: " << (end-start).count() << " ns\n";
    }
    std::cout << "\n";
}

int main() {
    using namespace std::literals;

    int numRuns = 1;
    runTestCase<SimpleSum<long long>, long long>(numRuns, "SimpleSum"sv);
    runTestCase<SimpleProd<long long>, long long>(numRuns, "SimpleProd"sv);
}
